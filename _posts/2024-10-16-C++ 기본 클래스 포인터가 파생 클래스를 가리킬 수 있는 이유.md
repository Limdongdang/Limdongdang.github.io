---
layout: single 
title: C++ 기본 클래스 포인터가 파생 클래스를 가리킬 수 있는 이유
toc: true
toc_label: "C++ 기본 클래스 포인터가 파생 클래스를 가리킬 수 있는 이유"
toc_sticky: true
---

c++ 다형성에 대해 공부하던 중 "멤버를 물려받기 때문에 가리킬 수 있다"는 설명 이해가 가지 않았습니다
### C++에서 상속과 가상 함수: 메모리 구조와 함수 호출 원리

C++에서 상속을 통해 **파생 클래스**는 **기본 클래스**의 모든 멤버(데이터와 함수)를 물려받습니다. 이를 통해 기본 클래스의 포인터로 파생 클래스의 객체를 가리킬 수 있습니다. 
하지만 단순히 "멤버를 물려받기 때문에 가리킬 수 있다"는 설명이 이해가 가지 않았습니다 

그래서 더 확실히 이해하기 위해, 메모리 구조와 가상 함수의 작동 방식에 대해 공부하게 되었습니다.
### 파생 클래스의 메모리 구조

기본 클래스를 상속받은 파생 클래스의 메모리 구조는 **기본 클래스의 멤버**들이 먼저 메모리에 저장되고, 그 다음에 **파생 클래스의 멤버**들이 추가로 저장되는 방식으로 이루어집니다. 나타내면 다음과 같습니다:
```
+-----------+--------------+
| Base 부분 | Derived 부분 |
+-----------+--------------+
```
이 구조 덕분에, **기본 클래스 포인터**는 파생 클래스 객체의 **기본 클래스 부분**을 가리킬 수 있습니다. 하지만 이때는 기본 클래스의 멤버들만 접근할 수 있고, 파생 클래스에 추가된 멤버들은 접근할 수 없습니다. 이는 포인터가 메모리 상에서 기본 클래스의 주소만을 가리키고 있기 때문입니다
### 가상 함수와 가상 테이블(vtable)

그렇다면 기본 클래스의 멤버만 접근 가능한 상태에서 어떻게 **다형성**을 활용할 수 있다는 말 일까요?  
이때 **가상 함수**를 사용하면, **파생 클래스의 오버라이드된 함수**에 접근하여 다형성을 구현할 수 있습니다. 이는 **가상 테이블(vtable)**과 **가상 포인터(vptr)** 덕분입니다.

가상 함수로 선언된 함수는 각 클래스마다 **가상 테이블**에 해당 함수의 주소가 저장됩니다. 그리고 객체의 첫 부분에 위치한 **가상 포인터(vptr)**가 이 가상 테이블을 가리킵니다. 

파생 클래스에서 가상 함수를 **오버라이드**하면, 파생 클래스의 **가상 테이블**에 그 오버라이드된 함수의 주소가 저장됩니다. 이 덕분에 **기본 클래스 포인터**를 사용하더라도 실제로는 **파생 클래스의 오버라이드된 함수**에 접근할 수 있게 되는 것이죠. 이를 통해 C++에서 **다형성**을 구현할 수 있습니다.
![image-20230623152919466](\assets\images\가상함수.png)